@tool
extends Node3D

#export var load_links: bool : set = _load_links

var MB_to_godot_path = "/run/media/cithoreal/Elements/MemoryBase/ToThoughts-Git/MB_to_godot.py"
var godot_to_nodes_path = "/run/media/cithoreal/Elements/MemoryBase/ToThoughts-Git/godot_to_nodes.py"
var thought_scene = load("res://Scenes/ThoughtBubble.tscn")
signal save_thoughts(timestamp)
signal load_links
signal load_parents

var thoughtbubble_store
var timestamp_list 
var timestamp_selector 
#func _load_links(_value):
#	emit_signal("load_links")
#var thread

#func _ready():
	
	
#func _exit_tree():
#	thread.wait_to_finish()

func load_timestamps(selector):
	if (get_viewport() == null):
		return

	if (timestamp_list == null || timestamp_list.is_empty()|| timestamp_list[0] == ""):
		thoughtbubble_store = get_viewport().get_child(0).get_node("ThoughtBubbleStore")
		var output = thoughtbubble_store.load(["Timestamp"])
		#print(output)
		if (!output[0] == "[" && output[0] != ""):
			timestamp_list = output
			timestamp_selector = selector
			return output[selector]
		else:
			return "not loaded"
	else:
		return timestamp_list[selector]

	
#Generated by Bing Chat
#func getIntersection(arrays):
#	var intersection = []
#	for item in arrays[0]:
#		var exists = true
#		for i in range(1, arrays.size()):
#			if !arrays[i].has(item):
#				exists = false
#				break
#		if exists:
#			intersection.append(item)
#	return intersection
	
func load_space():
	thoughtbubble_store = get_viewport().get_child(0).get_node("ThoughtBubbleStore")
	#print(loaded_nodes)
	#Add ability to intersect or union with other thought spaces in the scene
	#Child thought spaces intersect with their parents
	#Child thought spaces can at any point be "Expanded" to union instead
	#print(str(Time.get_time_string_from_system()) + ": Thought Space before Execute()")
	clear_scene()

	for node in thoughtbubble_store.get_nodes(["Text"]):
		print(node)
		load_thought(node)
		
	emit_signal("load_links")
	emit_signal("load_parents")
	#OS.execute(MB_to_godot_path, [get_parent().get_name(), "|Thought|"], true, output)
	#print(str(Time.get_time_string_from_system()) + ": Thought Space after Execute()")
	#process_thoughts(output)
#func load_space():
#
#	thoughtbubble_store = get_viewport().get_child(0).get_node("FileManager")
#	#print(loaded_nodes)
#	#Add ability to intersect or union with other thought spaces in the scene
#	#Child thought spaces intersect with their parents
#	#Child thought spaces can at any point be "Expanded" to union instead
#	#print(str(Time.get_time_string_from_system()) + ": Thought Space before Execute()")
#	clear_scene()
#	#Get thoughts from current and all previous timestamps
#	#for
#	for time in timestamp_list:
#		for node in thoughtbubble_store.get_from_orbitdb(["`Text`", time]):
#			print(node)
#			if node != "" && !find_child(node):
#				load_thought(node)
#		if time == get_parent().current_timestamp:
#			break
#
#	emit_signal("load_parents")
#	emit_signal("load_links")
#	#OS.execute(MB_to_godot_path, [get_parent().get_name(), "|Thought|"], true, output)
#	#print(str(Time.get_time_string_from_system()) + ": Thought Space after Execute()")
#	#process_thoughts(output)
	
func save():
	#Select the latest timestamp on a save
	if timestamp_list != null:
		timestamp_list.clear()
	print("saving thoughts")
	var timestamp = Time.get_unix_time_from_system()
	thoughtbubble_store = get_viewport().get_child(0).get_node("FileManager")
	#var space_dict = {}
	var save_timestamp
	# for node in get_children():
	# 	space_dict[node.get_name()] = node.get_child_thoughts()
	#thoughtbubble_store.save("MERGE (:Timestamp{})")
	#thoughtbubble_store.save(["`Timestamp`", str(timestamp)])
	if get_parent().is_focused:
		save_timestamp = get_parent().current_timestamp
		#get_parent().timestamp_selector += 1
	else:
		save_timestamp = get_parent().get_parent().get_parent().current_timestamp
		#get_parent().get_parent().get_parent().timestamp_selector += 1
		
	if str(get_parent().current_timestamp) != "not loaded" && get_parent().current_timestamp != null && get_parent().current_timestamp != "":
		print("saving backlink")
		thoughtbubble_store.save([str(timestamp), "`BackLink`", str(get_parent().current_timestamp)])
		thoughtbubble_store.save([str(get_parent().current_timestamp), "`Link`", str(timestamp)])
	# thoughtbubble_store.save(space_dict)
	#print(Time.get_datetime_string_from_system(true,true))
	#thoughtbubble_store.save(["`Timestamp`", str(timestamp)])
	#OS.execute(godot_to_nodes_path, [get_parent().get_name(), "|Timestamp|", timestamp], false)
	#OS.execute(godot_to_nodes_path, ["|Space|", "|Thought|", get_parent().get_name()], false)
	#emit_signal("save_thoughts", timestamp)
	if get_parent().is_focused:
		print("saving whole space")
		emit_signal("save_thoughts", timestamp)
	else:
		print("saving thought")
		get_parent().get_child(1).save_thought(timestamp)



#Prep the scene to be loaded with new thoughts
func clear_scene():
	if timestamp_list != null:
		timestamp_list.clear()
	for node in get_children():
		node.get_child(1).clear_links()
		node.free()
	
func load_thought(thought_text):
	if thought_text != "":
		var new_bubble = thought_scene.instantiate()
		new_bubble.set_name(thought_text)
		add_child(new_bubble)
		new_bubble.set_owner(get_viewport().get_child(0))
		new_bubble.initialize()
		new_bubble.get_child(1).load_thought_properties(get_parent().current_timestamp)
	
		

		

func create_and_link_new_thought(thought_text, linking_thoughts, position):
	if thought_text != "":

		var new_bubble = thought_scene.instantiate()
		new_bubble.set_name(thought_text)
		add_child(new_bubble)
		new_bubble.set_owner(get_viewport().get_child(0))
		new_bubble.initialize()
		new_bubble.translate(position)
		new_bubble.translate(Vector3(0,-2,0))
		for thought in linking_thoughts:
			if (thought != get_parent().get_name()):
				
				if (!find_child(thought).get_child(1).child_thoughts.has(new_bubble.get_name())):
					find_child(thought).get_child(1).child_thoughts.append(new_bubble.get_name())
				if (!new_bubble.get_child(1).parent_thoughts.has(thought)):
					new_bubble.get_child(1).parent_thoughts.append(thought)
		new_bubble.get_child(1)._load_link_nodes()

func new_thought_in_space(thought_text):
	if thought_text != "":
		var new_bubble = thought_scene.instantiate()
		new_bubble.set_name(thought_text)
		add_child(new_bubble)
		new_bubble.set_owner(get_viewport().get_child(0))
		new_bubble.initialize()
		new_bubble.get_child(1)._load_link_nodes()
		new_bubble.translate(Vector3(0,-2,0))
		

