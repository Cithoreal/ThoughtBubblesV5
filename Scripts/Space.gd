@tool
extends Node3D

#export var load_links: bool : set = _load_links

var MB_to_godot_path = "/run/media/cithoreal/Elements/MemoryBase/ToThoughts-Git/MB_to_godot.py"
var godot_to_nodes_path = "/run/media/cithoreal/Elements/MemoryBase/ToThoughts-Git/godot_to_nodes.py"
var thought_scene = load("res://Scenes/ThoughtBubble.tscn")
signal save_thoughts(timestamp)
signal load_links
signal load_parents

var thoughtbubble_store
var timestamp_list 
var timestamp_selector 
#func _load_links(_value):
#	emit_signal("load_links")
#var thread

#func _ready():
	
	
#func _exit_tree():
#	thread.wait_to_finish()

func load_timestamps(selector):
	if (get_viewport() == null):
		return

	if (timestamp_list == null || timestamp_list.is_empty()|| timestamp_list[0] == ""):
		thoughtbubble_store = get_viewport().get_child(0).get_node("ThoughtBubbleStore")
		var output = thoughtbubble_store.load_thoughts(["Timestamp"])
		print_debug(output)
		#print_debug(output)
		if (!output[0] == "[" && output[0] != ""):
			timestamp_list = output
			timestamp_selector = selector
			return output[selector]
		else:
			return "not loaded"
	else:
		#print_debug(len(timestamp_list))
		if len(timestamp_list) >= selector:
			return timestamp_list[selector]

	
#Generated by Bing Chat
#func getIntersection(arrays):
#	var intersection = []
#	for item in arrays[0]:
#		var exists = true
#		for i in range(1, arrays.size()):
#			if !arrays[i].has(item):
#				exists = false
#				break
#		if exists:
#			intersection.append(item)
#	return intersection
	
func load_space():
	thoughtbubble_store = get_viewport().get_child(0).get_node("ThoughtBubbleStore")
	#print_debug(loaded_nodes)
	#Add ability to intersect or union with other thought spaces in the scene
	#Child thought spaces intersect with their parents
	#Child thought spaces can at any point be "Expanded" to union instead
	#print_debug(str(Time.get_time_string_from_system()) + ": Thought Space before Execute()")
	clear_scene()
	print_debug(thoughtbubble_store.load_thoughts(["Text-Thought"]))
	for node in thoughtbubble_store.load_thoughts(["Text-Thought"]):
		print_debug(node)
		load_thought(node)
		
	emit_signal("load_links")
	emit_signal("load_parents")
	#OS.execute(MB_to_godot_path, [get_parent().get_name(), "|Thought|"], true, output)
	#print_debug(str(Time.get_time_string_from_system()) + ": Thought Space after Execute()")
	#process_thoughts(output)
#func load_space():
#
#	thoughtbubble_store = get_viewport().get_child(0).get_node("ThoughtBubbleStore")
#	#print_debug(loaded_nodes)
#	#Add ability to intersect or union with other thought spaces in the scene
#	#Child thought spaces intersect with their parents
#	#Child thought spaces can at any point be "Expanded" to union instead
#	#print_debug(str(Time.get_time_string_from_system()) + ": Thought Space before Execute()")
#	clear_scene()
#	#Get thoughts from current and all previous timestamps
#	#for
#	for time in timestamp_list:
#		for node in thoughtbubble_store.get_from_orbitdb(["`Text`", time]):
#			print_debug(node)
#			if node != "" && !find_child(node):
#				load_thought(node)
#		if time == get_parent().current_timestamp:
#			break
#
#	emit_signal("load_parents")
#	emit_signal("load_links")
#	#OS.execute(MB_to_godot_path, [get_parent().get_name(), "|Thought|"], true, output)
#	#print_debug(str(Time.get_time_string_from_system()) + ": Thought Space after Execute()")
#	#process_thoughts(output)
	
func save():
	#Select the latest timestamp on a save
	if timestamp_list != null:
		timestamp_list.clear()
	print_debug("saving thoughts")
	var timestamp = Time.get_unix_time_from_system()
	var currentTimestamp = null
	if get_parent().current_timestamp != null:
		currentTimestamp = thoughtbubble_store.get_thought_data(get_parent().current_timestamp)
	thoughtbubble_store = get_viewport().get_child(0).get_node("ThoughtBubbleStore")
		
	if str(currentTimestamp) != "not loaded" && currentTimestamp != null && currentTimestamp != "":
		print_debug("linking timestamp %s to %s" % [currentTimestamp, timestamp])
		thoughtbubble_store.save(str(timestamp), [["Timestamp-[%s]" % currentTimestamp,currentTimestamp], ["Timestamp-[%s]" % str(timestamp), str(timestamp)]])
	if get_parent().is_focused:
		print_debug("saving whole space")
		emit_signal("save_thoughts", timestamp)
	else:
		print_debug("saving thought")
		get_parent().get_child(1).save_thought(timestamp)



#Prep the scene to be loaded with new thoughts
func clear_scene():
	if timestamp_list != null:
		timestamp_list.clear()
	for node in get_children():
		node.get_child(1).clear_links()
		node.free()
	
func load_thought(thought_text):
	if thought_text != "":
		var new_bubble = thought_scene.instantiate()
		new_bubble.set_name(thought_text)
		add_child(new_bubble)
		new_bubble.set_owner(get_viewport().get_child(0))
		new_bubble.initialize()
		var timestamp = float(thoughtbubble_store.get_thought_data(get_parent().current_timestamp))
		new_bubble.get_child(1).load_thought_properties(timestamp)
	
		

		

func create_and_link_new_thought(thought_text, linking_thoughts, position):
	if thought_text != "":

		var new_bubble = thought_scene.instantiate()
		new_bubble.set_name(thought_text)
		add_child(new_bubble)
		new_bubble.set_owner(get_viewport().get_child(0))
		new_bubble.initialize()
		new_bubble.translate(position)
		new_bubble.translate(Vector3(0,-2,0))
		for thought in linking_thoughts:
			if (thought != get_parent().get_name()):
				
				if (!find_child(thought).get_child(1).child_thoughts.has(new_bubble.get_name())):
					find_child(thought).get_child(1).child_thoughts.append(new_bubble.get_name())
				if (!new_bubble.get_child(1).parent_thoughts.has(thought)):
					new_bubble.get_child(1).parent_thoughts.append(thought)
		new_bubble.get_child(1)._load_link_nodes()

func new_thought_in_space(thought_text):
	if thought_text != "":
		var new_bubble = thought_scene.instantiate()
		new_bubble.set_name(thought_text)
		add_child(new_bubble)
		new_bubble.set_owner(get_viewport().get_child(0))
		new_bubble.initialize()
		new_bubble.get_child(1)._load_link_nodes()
		new_bubble.translate(Vector3(0,-2,0))
		

